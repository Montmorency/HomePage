\chapter{Recurrence and Continued Fractions}
\section{Introduction}
This appendix takes the form of a brief and essential
set of notes on the the various algorithms, recurrence relations,
root finding methods, continued fractions, orthogonal polynomials that 
underlie the methods discussed in the main text. 
These are mainly mathematical results
that may not be so familiar to a materials scientist.

\section{Euclid's Algorithm}
As pointed out by Haydock in Ref.~\cite{weaire85} the 
use of three term recurrence formulae goes back to 
ancient Greece. 

To find the greatest common divisor of two numbers $a,b$ with
$a>b$, a recurrence relation can be set up. The starting orbitals are now 
selected from ${u_{n}}\in\mathbb{N}$ a subset of the 
natural numbers (the positive integers) with ${u_1>u_2,...,1}$.

\begin{algorithm}
\caption{Euclid$'$s Algorithm}\label{alg:euclid}
\begin{algorithmic}[1]
\Procedure{Euclid}{$a,b$}\Comment{Find greatest common divisor of a and b}
\While{($u_{n-1}>u_{n}$)}
\State $q = 0$
\While{($(u_{n-1}-qu_n) > 0$)}\Comment{This is the $H\psi$ step.}
\State $u_{n+1} = -(qu_{n} - u_{n-1})$
\State $q \gets q+1$
\EndWhile\label{quotientwhile}
\State $u_{n-1} \gets u_{n}$
\State $u_{n} \gets u_{n+1}$
\EndWhile\label{euclidendwhile}
\State \textbf{return} $b$\Comment{The gcd is $u_{n}$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

The use of Euclid's algorithm in the determination of 
the continued fraction representation of a real number
provides the most direct connection with the Haydock recursion
method. Instead of a continued fraction approximation to a real
number the materials scientist seeks a continued fraction
approximation to the Green's function G(E) evaluated 
at some energy.

If a number is written:
\begin{equation}
a=bq_{0} + r_{0}
\end{equation}

\begin{equation}
\frac{a}{b} = q_{0} + \frac{r_{0}}{b}
\frac{b}{r_{0}} = \frac{1}{\frac{a}{b} - q_{0}}
\end{equation}

Again the operation or `work' at each stage of the algorithm
is finding the value of the quotient $q_i$, The process
is again iterated until it terminates (in the case of a rational number)
or up to some desired precision if it is an irrational number.

%In fields of numbers euclids algorithm is used to determine
%the multiplicative inverse
%Euclid's Algorithm can be generalized 
%by analogy of Euclidean division from natural numbers
%to polynomial equations.
%\footnote{The connection between Lanczos,
%Euclidean Algorithms has been explored in pure number 
%theoretical and cryptographic literature \cite{compmath97}.
%perturbation theory of polynomials given in \cite{damanik10}.

\section{Newton's Method for Finding Roots}
Newton's method is a useful way to find the roots of a polynomial
equation. If $f(\gamma_i)$ is an approximate root of an equation,
let $f(\gamma_i+h)$ be the exact root then:
%
\begin{equation}
f(\gamma_i+h)=0
\end{equation}
%
if h is small then we can expand to first order in a 
Taylor series and write:
\begin{equation}
f(\gamma_i) + h f'(\gamma_{i})= 0
\end{equation}
%
or, equivalently:
%
\begin{equation}
h = -\frac{f(\gamma_{i})}{f'(\gamma_i)}.
\end{equation}

Finally, we can improve the guess at the approximate root:
%
\begin{equation}
\gamma_{i+1} =  \gamma_{i} + h,
\end{equation}
%
and iterate the whole procedure to whatever accuracy we desire.

\section{Sturm's Theorem}
The Sturm sequence provides a means of determining the number of 
roots for a given polynomial equation contained in a real interval.

\section{Rational Interpolation}
\label{app:ratint}
An algorithm to compute rational interpolants 
using continued fractions algorithm is described in Ref.~\cite{vidbergserene77}.
A generic function $C_N(z)$ is written as a continued fraction:
%
\begin{equation}
C_{N}(z) = \frac{a_{1}}{1+}\frac{a_{2}(z-z_{1})}{1+}...\frac{a_{N}(z-z_{N-1})}{1},
\end{equation}
%
where $z$ is the argument of the interpolating function
at the desired point, $z_{i}$ are the points the original function is sampled at,
and $a_{i}$ are the coefficients of the interpolating polynomial.
%
\begin{equation}
C_{N}(z_{i}) = u_{i}, \quad i=1,...N.
\end{equation}
%
the coefficients $a_{i}$ can be generated from the recursion relations:
%
\begin{equation}
a_{i} = g_{i}(z_{i}),\quad g_{i}(z_{i})=u_{i},\quad i=1,...,N.
\end{equation}
%
\begin{equation}
g_{p}(z) = \frac{g_{p-1}(z_{p-1}) - g_{p-1}(z)}{(z - z_{p-1})g_{p-1}(z)}, \quad p \geq 2.
\end{equation}
%
The value of the function can then be generated at the point $z$ using the relations:
%
\begin{equation}
C_{N}(z) = \frac{A_{N}(z)}{B_{N}(z)},
\end{equation}
%
where:
%
\begin{eqnarray}
A_{0}=0, \quad A_{1} = a_{1}, \quad B_{0}=B_{1}=1, \nonumber \\
A_{n+1}(z) = A_{n}(z) + (z-z_{n})a_{n+1}A_{n-1}(z), \nonumber \\
B_{n+1}(z) = B_{n}(z) + (z-z_{n})a_{n+1}B_{n-1}(z).
\end{eqnarray}


